package com.day08;

public class 面向对象 {
    public static void main(String[] args) {
        //面向对象的意义,提高了代码的可维护,以扩展,复用性
        /*面向过程的语言的话,只是简单的编写代码来解决某一个问题,面向对象简单的来讲就是要
        完成某一个任务的时候,首先要想到谁去完成这个任务;提到数据首先想到的是这个数据是哪个对象*/


        //面向对象包含封装,继承,多态


        //类
        // 用来描述一类事物的行为和属性(定义的时候要见名知意,首字母大写驼峰命名)
         /* 1.类里面的数据类型
        基本数据类型    (1)byte,short,int,long__________默认值为0
                      (2)float,double ________________默认值为0.0
                      (3)boolean______________________默认值为false

        引用数据类型    (4)类,接口, 数组,String______默认值为null*/


        //2.对象是真实存在的具体实例



       /* 创建类后,如何创建对象
        类名 对象名 =new 类名()

         创建完对象以后
         我们可以用对象去处理事情
         比如改变对象的属性(给对象赋值)
         或者让对象调用类中的方法来实现某种功能
         */


        //封装
        /*将数据和对数据的操作封装在一起,对象是什么,就封装对应的数据,并且提供数据对应的行为
        他的优点就是可以让编程变得简单,有什么事找对象然后调用方法就可以*/
        /*说白了就是定义对象的属性和方法,在封装后只调用就行,封装是就要考虑数据属性和方法可能遇到的
        情况,并且进行异常的处理*/

        //成员变量和局部变量(用this关键字就可以区别两种变量)
        /*局部变量就是将变量定义在方法的里面,而成员变量是将变量定义在方法的外面
        当两个变量同名时,运行代码会遵循就近原则来选去取离其最近的.

        PS:在class里面,如果声明变量时同时赋初值这是合法的,但是在声明变量以后
        用赋值语句进行赋值这是非法的!*/


        /*构造方法
         * (1)方法名和类的名字要一致
         * (2)有没有参数,分为带参数和不带参数
         * (3)有没有返回值,有返回值用return带回
         * 创建时不用手动构造,只需要手动构造即可
         *
         * 带参数的方法构造可能适合写死的类的属性的那种
         * 但是面对不确定那种,是要用户输入才可以的则需要空参的方法构造
         * 两个各有好处吧!
         * 如果我们没有进行方法的构造,那么系统会给我们进行构造默认的方法(不含参数)
         * 但是如果我们自己构造了方法后,系统就不会给我构造空参的方法
         *
         *
         *
         * 带参数的构造方法和不带参数的构造方法的方法的名字都相同,
         * 但是参数不同,这种叫做构造方法的重载
         *
         *
         * 对于成员变量.我们要提供他的get和set方法
         * 如果要进行其他操作的的时候我们要另外进行操作*/

        //快捷键 ctrl+D 复制光标所在的行
        //shift+alt+上/下 移动选择的代码
        //ctrl+左右 一次移动一个单词
        //ctrl+上下  滚动代码屏幕,但不移动光标位置
        //shift+ctrl+左右  逐词选中
        //ctrl+w  小范围的选中


        //当我们创建一个类的时候
        /*public class characters(){
            int age;
            String name;
            double weight;
        }*/
        //我们声明了一个类,然后我们创建两个对象
        /*characters objectA=new characters();
        characters objectB=new characters();*/
        //此时A和B指向的是两块不同的空间
        /*objectA=objectB;*/
        //经过上面的操作以后,objetA此时指向的空间地址是objectB的
        //那么此时两者就是完全相同的实例了,这里假设创建对象后并且给对象的属性赋值
        //即分配的内存空间上都有对应的数据,但是因为将B的地址赋值给了A也就导致此时
        //A内存以前的数据将没有办法访问,导致这块内存地址被占用
        //但是在java里有一种"垃圾回收的机制",它可以定期检测某个内存空间是否将不会在
        //被任何对象所调用,如果是那么它将会释放这些被占用的内存

        /*System.out.println(objectA);//输出A对象的物理地址
        System.out.println(objectB);//输出B对象的物理地址*/
    }
}
