线程的生命周期
1、创建线程对象-----新建状态
2、调用Start----就绪状态（可以抢cpu，有执行资格但是没有执行权（有抢的权力但是还没有抢到））
3、抢到CPU的执行权，---有资格执行---（运行状态）
    但是在运行状态有可能被其他的cpu抢走执行权-----从运行状态到就绪状态


    4、在运行的时候，如果线程遇到阻塞方法，就会从运行状态到  阻塞状态，这个状态没有执行资格（不能抢cpu）没有执行权（运行代码）
    阻塞状态执行结束回到就绪状态，重新抢CPU
    5、seelp计时等待
    6、wait等待状态



    7、但是如果线程的run方法执行完毕-------线程就会死亡变成垃圾（死亡状态）


线程的安全性
多个线程操作同一个数据时,会出现数据重复, 超出范围的票
出现的原因是,在线程在执行的时候具有随机性,随时会被其他线程抢去cpu
怎么解决问题,就是在线程操作共享数据的时候,不允许线程之间的互相抢占
也就是同步代码块----将操作共享数据的代码索起来
synchronized (锁){
   操作共享数据的代码
}
特点:1锁默认是打开的,当一个线程进去以后,锁自动关闭
    2当里面的代码全部执行完毕,线程出来,锁自动打开



同步方法
将synchronized关键字放在方法上
1、同步方法是锁住方法里面的所有代码
2、所对象不能自己指定但是也要唯一
    如果不是静态方法：锁对象就是this，方法的调用者
    如果是静态的方法：锁对象是当前类的字节码文件


StringBuilder  线程不同步,也就是不安全
StringBuffer  线程同步,安全
单线程 选第一个,多线程选第二个



Lock锁------可以手动的上锁和开锁
lock是一个接口,不能直接创建对象,可以用它的实现类ReentrantLock来实例画创建对象

锁可以用try-catch-fainlly包裹


死锁:


等待唤醒机制
(生产者消费者)
(阻塞队列实现了四个接口：
 1、iterable---可以使用迭代器和增强for
 2、collection---单列集合
 3、queue----队列
 4、blockingqueue---阻塞队列
 不能直接创建对象，只能创建它的是实现类对象
 ArrayBlockingQueue---底层是数组，有界
 LinkBlockingQueue---底层是数组，无界（只不过是很大很大，最大值为int的最大值）
 底层有锁不需要额外加锁
